# Powering Up With React
## Sergio Cruz

# First Component
- *React* is a javascript library for building user interfaces.
- Some people use it as the **V** from MVC's.
- It was built to solve the problem of large applications wtih data that change over time.
- Created by Facebook.
- When solving problems, we always must be thinking with respect to the **Component-Based Architecture**.
- A **Component** is sort of like a function call for UI elements.
- The **Virtual DOM** is the in-memory representation of the real DOM generated by React before any changes are made.
- This allows React to make **Diffing** based on the changes to be made between states and speeds up response times.
- *Componenets* extend from the `React.Component` base class.
```js
class StoryBox extends React.Component{
  render(){
    return( <div>Storybox </div>);
  }

  ReactDOM.render(
    <StoryBox />, docuemnt.getElementById('story-app')
  );
}
```
- Every single component **MUST** have a `render()` function.
- **JSX** allows us to include html in our Javascript.
- Both the class name and the element name must match.
- In the HTML, we include `id='story-app'` in a div.
- Dependencies:
  * react.js
  * react-dom.js
  * babel.js
  * components.js
- You can shorthand the DOM part using `let target = document.getElementById('robot-app');` and then passing target.
- Lower case is treated as html and upper case is treated as Javascript.
- When building html blocks in React, you must use `className` instead of `class` since it's a reserved word.
- To have React interpret the expression as Javascript, you just need to wrap the expression in `{ }`.
- You can use `topicsList.map( topic => <li>{topic}</li>)`.

# Talk Through Props
- There is a distinct pattern to be followed everytime:
  1. Create a new class.
  2. Inherit from React.Component
  3. Return JSX from render.
- When building components, start from the smallest component and work your way up.
- This is because you can include the earlier components in the larger ones.
- The arguments to Components in *React* are called props.
- These look just like attribute, value pairs: `author = Phillip Moriarty`.
- You read the props sent from a larger component to a smaller component using `this.props.<value>`.
- Don't forget that `<Comment />` is how you add a Component into other Components.
- It is proper nomenclature to precede a custom function written with _ .
- We can iterate through a list using `commentList.map( (comment) => { return( <Comment author={comment.author} body = {comment.body} key={comment.id} )})`;
- The key is to help React keep track of unique comments.
- `<img src={this.props.avatarUrl} alt={`${this.props.author}'s picture`} />`

# Component State
- To implement the hide/show comments problem, there are to methods:
  1. Direct DOM manipulation.
  2. Indirect DOM manipulation.
-  The **State** is a Javascript object that lives inside each component.
- You can access it using `this.state`.
- For this, we'll define `let commentNodes;` to be a variable to hold `<div className="comment-list">...`.
- For this to work, we'll need to create a class constructor:
```js
constructor(){
  super();

  this.state = {
    showComments: false
  };
}
```
- Just like other languages, the first thing that *must* be called in the constructor is `super()`.
- To change this, use `this.setState( {showComments: true})`.
- You'll also want to define the text to be changed inside the render function as well.
- *State* is vital to managing and building React apps.
```js
_toggleAbuse(event){
    event.preventDefault();
    this.setState({
      isAbusive: !this.state.isAbusive
    });
  }
```
- `<a href="#" onClick={this._toggleAbuse.bind(this)}>Report as Abuse</a>`.

# Sythentic Events
- To add an event listener we will use the `onSubmit` handler.
- `onSubmit={this._handleSubmit.bind(this)}`.
- If you don't add `.bind(this)` then it will not work due to being in a different context.
- **Refs** allow us to assign form values to properties on the component object.
- Example: `ref={(input) => this._author = input}`.
- React runs ref callbacks on render.
- You'll then assign the callback values to local values in the handler function: `let author = this._author`.
- To post the data, you'll use `this.props._addComment( author.value, body.value )`.
- Functions in Javascript are first class citizens.
- We use `concat()` instead of `push()` because it updates the array instead of returning a copy with the new value added.
- Due to this, you'll want the comments array in the constructor.
- To make sure events are consistent across all browsers, React wraps browsers native events into **Synthetic Events**.
- `onKeyUp={this._getCharacterCount.bind(this)}`.

# Talking to Remote Servers
- **Lifecycle Methods** are for communicating with remote servers.
- These are methods in react that are called while the component is being rendered for the first time or about to be removed from the DOM.
- To start, set the init state of `comments = []`.
- Ajax requests will be done with JQuery.
- The order of calls is:
  1. constructor.
  2. componentWillMount
  3. render
  4. componentDidMount
  5. componentWillUnmount
- **Mounting** means being rendered for the first time.
- **Polling** is when periodically request to see if new comments have been added.
```js
componentDidMount(){
    // check every 5 seconds for new comments
    setInterval(() =>  this._fetchComments(), 5000);
}
```
- React optimizes rendering by only updating the DOM when changes are detected.
- If you transition pages, then you could keep adding more and more timers.
- To solve this, we'll add `componentWillUnmount(){ clearInterval( this._timer);}`.
- An **Optimistic Update** is when you give the user immediate feedback even when the remote server has not processed the change.
- `..` is called the **Spread Operator**.
- Always check to make sure a user wants to delete data.
- **One-Way Control Flow** is when you force changes from a higher level component to a lower level component.
